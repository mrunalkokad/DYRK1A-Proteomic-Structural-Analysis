# -*- coding: utf-8 -*-
"""proteinwork.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1YS3aHeAWg9iPYz32lsLVzNc1O2ANPEvG
"""

! pip install biopython

sequence1 = """SMSSHKKERKVYNDGYDDDNYDYIVKNGEKWMDRYEIDSLIGKGSFGQVVKAYDRVEQEWVAIKIIKNKK
AFLNQAQIEVRLLELMNKHDTEMKYYIVHLKRHFMFRNHLCLVFEMLSYNLYDLLRNTNFRGVSLNLTRK
FAQQMCTALLFLATPELSIIHCDLKPENILLCNPKRSAIKIVDFGSSCQLGQRIYQXIQSRFYRSPEVLL
GMPYDLAIDMWSLGCILVEMHTGEPLFSGANEVDQMNKIVEVLGIPPAHILDQAPKARKFFEKLPDGTWN
LKKTKDGKREYKPPGTRKLHNILGVETGGPGGRRAGESGHTVADYLKFKDLILRMLDYDPKTRIQPYYAL
QHSFFKKTADE"""

from Bio.SeqUtils.ProtParam import ProteinAnalysis

sequence1 = """SMSSHKKERKVYNDGYDDDNYDYIVKNGEKWMDRYEIDSLIGKGSFGQVVKAYDRVEQEWVAIKIIKNKK
AFLNQAQIEVRLLELMNKHDTEMKYYIVHLKRHFMFRNHLCLVFEMLSYNLYDLLRNTNFRGVSLNLTRK
FAQQMCTALLFLATPELSIIHCDLKPENILLCNPKRSAIKIVDFGSSCQLGQRIYQXIQSRFYRSPEVLL
GMPYDLAIDMWSLGCILVEMHTGEPLFSGANEVDQMNKIVEVLGIPPAHILDQAPKARKFFEKLPDGTWN
LKKTKDGKREYKPPGTRKLHNILGVETGGPGGRRAGESGHTVADYLKFKDLILRMLDYDPKTRIQPYYAL
QHSFFKKTADE"""

prot_param = ProteinAnalysis(sequence1)
amino_acid_composition = prot_param.get_amino_acids_percent()

for aa, percent in amino_acid_composition.items():
    print(f"{aa}: {percent:.2f}%")

amino_acids = list(amino_acid_composition.keys())
percentages = list(amino_acid_composition.values())

import matplotlib.pyplot as plt

plt.figure(figsize=(10, 6))
plt.bar(amino_acids, percentages, color='Violet')
plt.xlabel('Amino Acids')
plt.ylabel('Percentage')
plt.title('Amino Acid Composition for chain A')
plt.ylim(0, max(percentages) + 0.01)  # Set y-axis limit for better visualization
plt.grid(axis='y', linestyle='--', alpha=0.7)
plt.show()

prot_param = ProteinAnalysis(sequence1)
amino_acid_composition = prot_param.get_amino_acids_percent()

! sudo apt update
! sudo apt install dssp

from Bio.SeqUtils import IsoelectricPoint

pI_calculator1 = IsoelectricPoint.IsoelectricPoint(sequence1)
pI1 = pI_calculator1.pi()

print(f"The isoelectric point (pI) of the sequence is: {pI1}")

from Bio.Blast import NCBIWWW

# Run BLAST search
result_handle = NCBIWWW.qblast("blastp", "nr", sequence1)

# Save the output
with open("blast_results.xml", "w") as out_file:
    out_file.write(result_handle.read())

print("BLAST search completed!")

# Extract homologous sequences from BLAST results
from Bio.Blast import NCBIXML

result_handle = open("blast_results.xml")
blast_records = NCBIXML.parse(result_handle)

with open("homologs_7O7K.fasta", "w") as fasta_file:
    for record in blast_records:
        for alignment in record.alignments:
            for hsp in alignment.hsps:
                fasta_file.write(f">{alignment.title}\n{hsp.sbjct}\n")

print("Homologous sequences saved in homologs.fasta")

import xml.etree.ElementTree as ET
import networkx as nx
import matplotlib.pyplot as plt
import plotly.graph_objects as go

# Load the BLAST XML file
blast_xml_file = "blast_results.xml"
tree = ET.parse(blast_xml_file)
root = tree.getroot()

# Extract query name
query_name = root.find("BlastOutput_query-def").text

# Extract hits
hits = []
for hit in root.findall(".//Hit"):
    hit_id = hit.find("Hit_id").text
    bit_score = float(hit.find(".//Hsp_bit-score").text)
    identity = int(hit.find(".//Hsp_identity").text)  # Number of identical matches
    hit_length = int(hit.find("Hit_len").text)  # Length of the hit sequence
    percent_identity = (identity / hit_length) * 100  # Identity percentage
    hits.append((hit_id, bit_score, percent_identity))

# Sort by bit score and get the top 10 hits
top_hits = sorted(hits, key=lambda x: x[1], reverse=True)[:10]

# Create a directed graph
G = nx.DiGraph()

# Add query node
G.add_node(query_name, size=50, color='red')

# Add hit nodes and edges
for hit in top_hits:
    hit_id, bit_score, percent_identity = hit
    G.add_node(hit_id, size=30, color='blue')  # Nodes for hits
    G.add_edge(query_name, hit_id, weight=bit_score, identity=percent_identity)  # Edge with weight

# Generate positions using spring layout
pos = nx.spring_layout(G, seed=42)

# Extract edge data
edges, weights, labels = zip(*[(edge, G.edges[edge]['weight'], G.edges[edge]['identity']) for edge in G.edges])

# Convert positions for Plotly
edge_x = []
edge_y = []
for edge in G.edges():
    x0, y0 = pos[edge[0]]
    x1, y1 = pos[edge[1]]
    edge_x.append(x0)
    edge_x.append(x1)
    edge_x.append(None)
    edge_y.append(y0)
    edge_y.append(y1)
    edge_y.append(None)

# Create edge traces
edge_trace = go.Scatter(
    x=edge_x, y=edge_y,
    line=dict(width=1, color='gray'),
    hoverinfo='none',
    mode='lines'
)

# Create node traces
node_x, node_y, node_text, node_size, node_color = [], [], [], [], []
for node in G.nodes():
    x, y = pos[node]
    node_x.append(x)
    node_y.append(y)
    node_text.append(f"{node} ({G.nodes[node]['size']})")
    node_size.append(G.nodes[node]['size'])
    node_color.append(G.nodes[node]['color'])

node_trace = go.Scatter(
    x=node_x, y=node_y,
    mode='markers+text',
    text=node_text,
    textposition="top center",
    marker=dict(
        size=node_size,
        color=node_color,
        line=dict(width=2, color='black')
    ),
    hoverinfo='text'
)

# Create figure
fig = go.Figure(data=[edge_trace, node_trace])

fig.update_layout(
    title="Network Graph of BLAST Hits",
    showlegend=False,
    hovermode='closest',
    margin=dict(b=10, l=10, r=10, t=50),
    xaxis=dict(showgrid=False, zeroline=False, showticklabels=False),
    yaxis=dict(showgrid=False, zeroline=False, showticklabels=False)
)

fig.show()

from Bio.PDB import PDBList, PDBParser

# Create a PDBList object to fetch PDB files
pdb_list = PDBList()

# Download the PDB file
pdb_file = pdb_list.retrieve_pdb_file('7o7k', file_format='pdb')

# Create a PDBParser object to parse the PDB file
parser = PDBParser()

# Parse the structure from the downloaded PDB file
structure = parser.get_structure('7o7k', pdb_file)

# Print some information about the structure
for model in structure:
    print(f"Model {model.id}")
    for chain in model:
        print(f" Chain {chain.id}")
        for residue in chain:
            print(f"  Residue {residue.resname} at position {residue.id[1]}")

import matplotlib.pyplot as plt

# Initialize lists to hold data for plotting
chain_ids = []
residue_positions = []

# Extract information about residues
for model in structure:
    for chain in model:
        for residue in chain:
            chain_ids.append(chain.id)
            residue_positions.append(residue.id[1])

# Create a scatter plot
plt.figure(figsize=(8, 6))
plt.scatter(residue_positions, chain_ids, alpha=0.6)
plt.xlabel('Residue Position')
plt.ylabel('Chain ID')
plt.title('Residue Positions in PDB Structure 7o7k')
plt.grid(True)
plt.show()

# Create a scatter plot
plt.figure(figsize=(8, 6))
plt.scatter(residue_positions, chain_ids, alpha=0.6, color = 'Purple')
plt.xlabel('Residue Position')
plt.ylabel('Chain ID')
plt.title('Residue Positions in PDB Structure 7o7k')
plt.grid(True)
plt.show()

#code to extract the alpha carbon coordinates from the PDB file and plot them in 3D:
from mpl_toolkits.mplot3d import Axes3D

# Parse the structure from the PDB file
structure = parser.get_structure('7o7k', pdb_file)

# Lists to hold coordinates
x_coords = []
y_coords = []
z_coords = []

# Extract CA atom coordinates
for model in structure:
    for chain in model:
        for residue in chain:
            if 'CA' in residue:
                ca_atom = residue['CA']
                x_coords.append(ca_atom.coord[0])
                y_coords.append(ca_atom.coord[1])
                z_coords.append(ca_atom.coord[2])

# Plotting
fig = plt.figure(figsize=(10, 6))
ax = fig.add_subplot(111, projection='3d')
ax.scatter(x_coords, y_coords, z_coords, s=20, color='Red', marker='*')

ax.set_xlabel('X axis')
ax.set_ylabel('Y axis')
ax.set_zlabel('Z axis')

plt.title('3D Scatter plot of Alpha Carbons')
plt.show()

from Bio.PDB import PDBParser
import numpy as np
import matplotlib.pyplot as plt

# Initialize parser
parser = PDBParser()
structure = parser.get_structure('7o7k', pdb_file)

# Extract CA atom coordinates
ca_atoms = []
for model in structure:
    for chain in model:
        for residue in chain:
            if 'CA' in residue:
                ca_atoms.append(residue['CA'])

# Compute distance matrix
num_atoms = len(ca_atoms)
dist_matrix = np.zeros((num_atoms, num_atoms))
for i in range(num_atoms):
    for j in range(num_atoms):
        dist_matrix[i, j] = ca_atoms[i] - ca_atoms[j]

# Plotting
plt.imshow(dist_matrix, cmap='coolwarm')  # plasma, inferno, cividis
plt.colorbar()
plt.title('Distance Matrix Plot')
plt.xlabel('Residue Index')
plt.ylabel('Residue Index')
plt.show()

Color Intensity and Distance:

The plot uses a color map ('viridis') where different colors represent different distances between CA atoms. The color bar on the side of the plot indicates the scale of distances. Lighter colors typically represent shorter distances, while darker colors represent longer distances. Axes:

The x-axis and y-axis both represent the residue index. If the protein has n residues with CA atoms, the axes range from 0 to n-1. Each point (i, j) on the plot represents the distance between the CA atom of residue i and the CA atom of residue j. Diagonal Line:

The diagonal line from the bottom-left to the top-right of the plot represents the distance of each CA atom to itself, which is always zero. This line will be the lightest color, indicating zero distance. Symmetry:

The distance matrix is symmetric, meaning the distance from residue i to residue j is the same as the distance from residue j to residue i. Thus, the plot will be symmetric along the diagonal. Clusters and Structure:

Clusters of lighter colors (shorter distances) indicate regions of the protein where residues are close to each other. These clusters can correspond to secondary structure elements like alpha helices or beta sheets. Larger patches of darker colors (longer distances) might indicate regions of the protein that are farther apart, potentially different domains or ends of the protein. By analyzing this plot, you can gain insights into the spatial arrangement of residues within the protein. For example, regions of high intensity (lighter colors) could suggest tight packing or close interactions, while regions of low intensity (darker colors) indicate residues that are spatially distant from each other.

! pip install biopython

from Bio import PDB
from Bio.PDB import PDBParser, PPBuilder
import matplotlib.pyplot as plt

def generate_ramachandran(pdb_id):
    pdbl = PDB.PDBList()
    pdb_file = pdbl.retrieve_pdb_file(pdb_id, file_format="pdb")

    parser = PDB.PDBParser()
    structure = parser.get_structure(pdb_id, pdb_file)

    phi_angles = []
    psi_angles = []

    ppb = PPBuilder()
    for pp in ppb.build_peptides(structure):
        phi_psi = pp.get_phi_psi_list()
        for angles in phi_psi:
            phi_angle = angles[0]
            psi_angle = angles[1]
            if phi_angle is not None and psi_angle is not None:
                phi_angles.append(float(phi_angle))
                psi_angles.append(float(psi_angle))

    return phi_angles, psi_angles

def plot_ramachandran(phi_angles, psi_angles):
    plt.scatter(phi_angles, psi_angles, marker='o', s=15, alpha=0.6)
    plt.xlabel('Phi Angle (degrees)')
    plt.ylabel('Psi Angle (degrees)')
    plt.title('Ramachandran Plot')
    plt.grid(True)
    plt.show()
#  desired PDB ID
pdb_id = '7O7K'
phi_angles, psi_angles = generate_ramachandran(pdb_id)
plot_ramachandran(phi_angles,psi_angles)

import matplotlib.pyplot as plt
import numpy as np
from Bio import PDB
from Bio.SeqUtils import IUPACData

# Kyte-Doolittle Hydrophobicity Scale
hydrophobicity_scale = {
    "I": 4.5, "V": 4.2, "L": 3.8, "F": 2.8, "C": 2.5,
    "M": 1.9, "A": 1.8, "G": -0.4, "T": -0.7, "S": -0.8,
    "W": -0.9, "Y": -1.3, "P": -1.6, "H": -3.2, "E": -3.5,
    "Q": -3.5, "D": -3.5, "N": -3.5, "K": -3.9, "R": -4.5
}

# Load PDB file and extract sequence
parser = PDB.PDBParser()
structure = parser.get_structure("7O7K", "7o7k.pdb")

sequence = ""
for model in structure:
    for chain in model:
        for residue in chain:
            res_name = residue.get_resname()
            try:
                one_letter = IUPACData.protein_letters_3to1[res_name.capitalize()]  # Convert to one-letter code
                sequence += one_letter
            except KeyError:
                continue  # Ignore non-standard amino acids
# Compute hydrophobicity scores
hydrophobicity_values = [hydrophobicity_scale.get(aa, 0) for aa in sequence]

# Smoothing using a sliding window (window size = 5)
window_size = 5
smoothed_hydrophobicity = np.convolve(hydrophobicity_values, np.ones(window_size) / window_size, mode="valid")

# Plot Hydrophobicity Distribution
plt.figure(figsize=(10,5))
plt.plot(smoothed_hydrophobicity, label="Hydrophobicity", color="violet")
plt.axhline(0, color="gray", linestyle="--")
plt.xlabel("Residue Index")
plt.ylabel("Kyte-Doolittle Hydrophobicity Score")
plt.title("Hydrophobicity Distribution of 7O7K")
plt.legend()
plt.show()

from Bio.PDB import PDBList, PDBParser, is_aa
import matplotlib.pyplot as plt
from collections import Counter, defaultdict
import os

# Step 1: Download and parse the structure
pdbl = PDBList()
pdb_id = "7O7K"
filename = pdbl.retrieve_pdb_file(pdb_id, pdir='.', file_format='pdb')
parser = PDBParser()
structure = parser.get_structure(pdb_id, filename)

# Containers
residues = []
b_factors = []
residue_positions = []
atom_types = []
chain_residue_counts = defaultdict(int)
residue_masses = []

# Approximate residue masses (in Da)
mass_table = {
    'ALA': 89.1, 'ARG': 174.2, 'ASN': 132.1, 'ASP': 133.1, 'CYS': 121.2,
    'GLU': 147.1, 'GLN': 146.2, 'GLY': 75.1, 'HIS': 155.2, 'ILE': 131.2,
    'LEU': 131.2, 'LYS': 146.2, 'MET': 149.2, 'PHE': 165.2, 'PRO': 115.1,
    'SER': 105.1, 'THR': 119.1, 'TRP': 204.2, 'TYR': 181.2, 'VAL': 117.1
}
# Extract data
for model in structure:
    for chain in model:
        for residue in chain:
            if is_aa(residue):
                resname = residue.get_resname()
                residues.append(resname)
                chain_residue_counts[chain.id] += 1
                residue_positions.append(residue.get_id()[1])
                b_list = [atom.get_bfactor() for atom in residue]
                b_factors.append(sum(b_list) / len(b_list))
                residue_masses.append(mass_table.get(resname, 0))
                for atom in residue:
                    atom_types.append(atom.element)



# Plot 1: Residue-wise Average B-factor
plt.figure(figsize=(10, 4))
plt.plot(residue_positions, b_factors, marker='o', linestyle='-', color='brown')
plt.title("Average B-factor per Residue")
plt.xlabel("Residue Position")
plt.ylabel("Avg B-factor")
plt.tight_layout()
plt.show()

# Plot 2: Atom Type Frequency
plt.figure(figsize=(8, 4))
plt.bar(*zip(*Counter(atom_types).items()), color='orange')
plt.title("Atom Type Frequency")
plt.xlabel("Atom Type")
plt.ylabel("Count")
plt.tight_layout()
plt.show()

# Plot 3: Histogram of B-Factors
plt.figure(figsize=(8, 4))
plt.hist(b_factors, bins=30, color='teal', edgecolor='black')
plt.title("Histogram of B-factors")
plt.xlabel("B-factor")
plt.ylabel("Frequency")
plt.tight_layout()
plt.show()

# Plot 4: Approximate Residue Mass Distribution
plt.figure(figsize=(10, 4))
plt.plot(residue_positions, residue_masses, color='blue', linestyle='--', marker='s')
plt.title("Residue Mass Distribution")
plt.xlabel("Residue Position")
plt.ylabel("Approx. Mass (Da)")
plt.tight_layout()
plt.show()

! pip install biopython

! pip install rdkit

import os
import numpy as np
import pandas as pd
import requests
from Bio.PDB import PDBList
from rdkit import Chem
from rdkit.Chem import Descriptors, AllChem
import joblib

import os
import numpy as np
import pandas as pd
import requests
from Bio.PDB import PDBList
from rdkit import Chem
from rdkit.Chem import Descriptors, AllChem
from sklearn.ensemble import RandomForestClassifier
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from sklearn.metrics import classification_report, roc_auc_score
import joblib

# ---------- STEP 1: DOWNLOAD PROTEIN STRUCTURES ----------
pdb_ids = ['6CVP', '3CQP', '7Y6J', '4FED', '7OW1', '5TPT', '8J47']
pdb_dir = "./data/pdb/"
os.makedirs(pdb_dir, exist_ok=True)
pdbl = PDBList()
for pdb_id in pdb_ids:
    pdbl.retrieve_pdb_file(pdb_id, pdir=pdb_dir, file_format='pdb')

import requests

# Given mapping of PDB IDs to UniProt IDs
pdb_uniprot_mapping = {
    "6CVP": "Q7Z2E3",
    "3CQP": "P00441",
    "7Y6J": "P02766",
    "4FED": "P42858",
    "7OW1": "P05067",
    "5TPT": "Q06481",
    "8J47": "B7Z313"
}

def get_uniprot_fasta(uniprot_id):
    url = f"https://rest.uniprot.org/uniprotkb/{uniprot_id}.fasta"
    response = requests.get(url)
    if response.status_code == 200:
        return response.text
    else:
        print(f"Failed to fetch FASTA for UniProt ID: {uniprot_id}")
        return None

# Download and save FASTA for each PDB-UniProt pair
for pdb_id, uniprot_id in pdb_uniprot_mapping.items():
    print(f"Fetching FASTA for PDB: {pdb_id}, UniProt ID: {uniprot_id}")
    fasta = get_uniprot_fasta(uniprot_id)
    if fasta:
        with open(f"{pdb_id}_{uniprot_id}.fasta", "w") as f:
            f.write(fasta)

import requests
import pandas as pd

# UniProt IDs you provided
uniprot_ids = ["Q7Z2E3", "P00441", "P02766", "P05067", "Q06481", "B7Z313","P42858"]

def fetch_string_ppi(uniprot_id, species=9606, required_score=700):
    url = "https://string-db.org/api/tsv/network"
    params = {
        "identifiers": uniprot_id,
        "species": species,  # Human
        "required_score": required_score  # High confidence interactions
    }
    response = requests.get(url, params=params)
    if response.status_code == 200:
        return response.text
    else:
        print(f"STRING API failed for {uniprot_id}")
        return None

# Save PPI data for each UniProt ID
for uid in uniprot_ids:
    print(f"Fetching STRING PPI for {uid}")
    result = fetch_string_ppi(uid)
    if result:
        with open(f"{uid}_STRING_PPI.tsv", "w") as f:
            f.write(result)

